use crate::dns::types::base::RawString;
use crate::dns::utils::SliceReader;
use smallvec::SmallVec;
use std::fmt::Display;
use std::rc::Rc;

#[derive(Clone, Debug)]
pub struct TXT(Rc<SmallVec<[RawString; 1]>>);

impl TXT {
    #[inline]
    pub fn get_index(&self) -> Rc<SmallVec<[RawString; 1]>> {
        self.0.clone()
    }

    #[inline]
    pub fn get_general_output(&self) -> Option<Vec<String>> {
        Some(self.0.iter().map(|v| v.to_string()).collect())
    }

    #[cfg(feature = "fmt")]
    #[inline]
    pub fn fmt_with_suffix(&self, f: &mut std::fmt::Formatter, _indent: &str) -> std::fmt::Result {
        writeln!(f, "{_indent}TXT:")?;
        for v in self.0.iter() {
            write!(f, "{_indent}\t")?;
            Display::fmt(v, f)?;
        }
        Ok(())
    }

    #[inline]
    pub fn from_reader_with_size(reader: &mut SliceReader, _raw_len: usize) -> Option<TXT> {
        let pos = reader.pos();
        let mut vec = SmallVec::new();
        while reader.pos() < _raw_len + pos {
            if let Some(v) = RawString::from_reader_with_maximum(reader, _raw_len + pos) {
                vec.push(v);
            } else {
                break;
            }
        }
        if vec.is_empty() {
            return None;
        }
        Some(TXT(vec.into()))
    }
}

#[cfg(test)]
mod tests {
    use crate::dns::types::base::record::TXT;
    use crate::dns::utils::SliceReader;

    #[test]
    pub fn test_txt_from_reader() {
        let slice = [
            0x94_u8, 0x20, 0x81, 0x80, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x02, 0x66,
            0x73, 0x09, 0x67, 0x6c, 0x6f, 0x72, 0x79, 0x6f, 0x75, 0x74, 0x68, 0x03, 0x63, 0x6f,
            0x6d, 0x00, 0x00, 0x10, 0x00, 0x01, 0xc0, 0x0c, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00,
            0x02, 0x30, 0x00, 0x37, 0x36, 0x76, 0x65, 0x72, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74,
            0x69, 0x6f, 0x6e, 0x2d, 0x63, 0x6f, 0x64, 0x65, 0x2d, 0x73, 0x69, 0x74, 0x65, 0x2d,
            0x41, 0x70, 0x70, 0x5f, 0x66, 0x65, 0x69, 0x73, 0x68, 0x75, 0x3d, 0x34, 0x7a, 0x43,
            0x44, 0x59, 0x74, 0x73, 0x77, 0x51, 0x46, 0x48, 0x43, 0x71, 0x69, 0x6e, 0x79, 0x78,
            0x64, 0x61, 0x61, 0xc0, 0x0c, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x02, 0x30, 0x00,
            0x2c, 0x2b, 0x76, 0x3d, 0x73, 0x70, 0x66, 0x31, 0x20, 0x2b, 0x69, 0x6e, 0x63, 0x6c,
            0x75, 0x64, 0x65, 0x3a, 0x5f, 0x6e, 0x65, 0x74, 0x62, 0x6c, 0x6f, 0x63, 0x6b, 0x73,
            0x2e, 0x6d, 0x2e, 0x66, 0x65, 0x69, 0x73, 0x68, 0x75, 0x2e, 0x63, 0x6e, 0x20, 0x2d,
            0x61, 0x6c, 0x6c,
        ];
        let mut reader = SliceReader::from_slice(&slice);
        reader.set_pos(46);
        let txt = TXT::from_reader_with_size(&mut reader, 55);
        assert_eq!(reader.as_ref()[reader.pos()], 192);
    }
}
